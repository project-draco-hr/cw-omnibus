{
  byte[] data=response.data;
  BitmapFactory.Options decodeOptions=new BitmapFactory.Options();
  Bitmap bitmap=null;
  if (mMaxWidth == 0 && mMaxHeight == 0) {
    decodeOptions.inPreferredConfig=mDecodeConfig;
    bitmap=BitmapFactory.decodeByteArray(data,0,data.length,decodeOptions);
  }
 else {
    decodeOptions.inJustDecodeBounds=true;
    BitmapFactory.decodeByteArray(data,0,data.length,decodeOptions);
    int actualWidth=decodeOptions.outWidth;
    int actualHeight=decodeOptions.outHeight;
    int desiredWidth=getResizedDimension(mMaxWidth,mMaxHeight,actualWidth,actualHeight,mScaleType);
    int desiredHeight=getResizedDimension(mMaxHeight,mMaxWidth,actualHeight,actualWidth,mScaleType);
    decodeOptions.inJustDecodeBounds=false;
    decodeOptions.inSampleSize=findBestSampleSize(actualWidth,actualHeight,desiredWidth,desiredHeight);
    Bitmap tempBitmap=BitmapFactory.decodeByteArray(data,0,data.length,decodeOptions);
    if (tempBitmap != null && (tempBitmap.getWidth() > desiredWidth || tempBitmap.getHeight() > desiredHeight)) {
      bitmap=Bitmap.createScaledBitmap(tempBitmap,desiredWidth,desiredHeight,true);
      tempBitmap.recycle();
    }
 else {
      bitmap=tempBitmap;
    }
  }
  if (bitmap == null) {
    return Response.error(new ParseError(response));
  }
 else {
    return Response.success(bitmap,HttpHeaderParser.parseCacheHeaders(response));
  }
}
